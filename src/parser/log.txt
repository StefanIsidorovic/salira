bison -v -d lambda.y
flex lambda.l
g++ -std=c++11 lex.yy.cc main.cpp lambda.tab.c ../exp_hierarchy/functor.cc -o proba
In file included from ../exp_hierarchy/metafunc.hh:5:0,
                 from ../exp_hierarchy/functor.hh:5,
                 from ../exp_hierarchy/auto_load.hh:6,
                 from lambda.l:7:
../exp_hierarchy/salira_utility.hh: In static member function ‘static void SaliraUtility::insertFunctionInPool(std::string, Expression, std::vector<ExpressionBase*>)’:
../exp_hierarchy/salira_utility.hh:35:5: error: ‘Functor’ has not been declared
     Functor::insertFunc(identifier, SaliraUtility::makeLambda(e), args);
     ^
In file included from ../exp_hierarchy/metafunc.hh:6:0,
                 from ../exp_hierarchy/functor.hh:5,
                 from ../exp_hierarchy/auto_load.hh:6,
                 from lambda.l:7:
../exp_hierarchy/salira_types.hh: In member function ‘virtual bool PrimitiveValue::isConstant() const’:
../exp_hierarchy/salira_types.hh:17:49: error: expected ‘;’ before ‘}’ token
     virtual bool isConstant() const {return true}
                                                 ^
../exp_hierarchy/salira_types.hh: In member function ‘virtual bool SaliraInt::isConstant() const’:
../exp_hierarchy/salira_types.hh:37:47: error: expected ‘;’ before ‘}’ token
   virtual bool isConstant() const {return true}
                                               ^
../exp_hierarchy/salira_types.hh: In member function ‘virtual ExpressionBase* SaliraInt::eval(const std::vector<ExpressionBase*>&) const’:
../exp_hierarchy/salira_types.hh:41:32: error: invalid new-expression of abstract class type ‘SaliraInt’
     return new SaliraInt(_value);
                                ^
../exp_hierarchy/salira_types.hh:27:7: note:   because the following virtual functions are pure within ‘SaliraInt’:
 class SaliraInt : public PrimitiveValue {
       ^
In file included from ../exp_hierarchy/auto_load.hh:5:0,
                 from lambda.l:7:
../exp_hierarchy/expression.hh:34:16: note: 	virtual bool ExpressionBase::isToken() const
   virtual bool isToken() const = 0;
                ^
In file included from ../exp_hierarchy/metafunc.hh:6:0,
                 from ../exp_hierarchy/functor.hh:5,
                 from ../exp_hierarchy/auto_load.hh:6,
                 from lambda.l:7:
../exp_hierarchy/salira_types.hh: At global scope:
../exp_hierarchy/salira_types.hh:52:13: error: expected unqualified-id before ‘double’
   SaliraInt(double value) : PrimitiveValue(), _value(value) {}
             ^
../exp_hierarchy/salira_types.hh:52:13: error: expected ‘)’ before ‘double’
../exp_hierarchy/salira_types.hh: In member function ‘virtual ExpressionBase* SaliraDouble::eval(const std::vector<ExpressionBase*>&) const’:
../exp_hierarchy/salira_types.hh:59:35: error: invalid new-expression of abstract class type ‘SaliraDouble’
     return new SaliraDouble(_value);
                                   ^
../exp_hierarchy/salira_types.hh:48:7: note:   because the following virtual functions are pure within ‘SaliraDouble’:
 class SaliraDouble : public PrimitiveValue {
       ^
In file included from ../exp_hierarchy/auto_load.hh:5:0,
                 from lambda.l:7:
../exp_hierarchy/expression.hh:34:16: note: 	virtual bool ExpressionBase::isToken() const
   virtual bool isToken() const = 0;
                ^
In file included from ../exp_hierarchy/metafunc.hh:6:0,
                 from ../exp_hierarchy/functor.hh:5,
                 from ../exp_hierarchy/auto_load.hh:6,
                 from lambda.l:7:
../exp_hierarchy/salira_types.hh: At global scope:
../exp_hierarchy/salira_types.hh:68:38: error: expected class-name before ‘{’ token
 class SaliraList : public Expression {
                                      ^
../exp_hierarchy/salira_types.hh:70:3: error: ‘Type’ does not name a type
   Type _type_of_elements;
   ^
../exp_hierarchy/salira_types.hh:73:19: error: expected ‘)’ before ‘type’
   SaliraList(Type type) : _type_of_elements(type) {}
                   ^
../exp_hierarchy/salira_types.hh: In constructor ‘Token::Token(int, ExpressionBase::Type)’:
../exp_hierarchy/salira_types.hh:102:64: error: expected ‘{’ before ‘ExpressionBase’
   Token(int place, Type type) : _placement(place), _type(type) ExpressionBase(false) {}
                                                                ^
In file included from ../exp_hierarchy/functor.hh:5:0,
                 from ../exp_hierarchy/auto_load.hh:6,
                 from lambda.l:7:
../exp_hierarchy/metafunc.hh: At global scope:
../exp_hierarchy/metafunc.hh:24:56: error: ISO C++ forbids declaration of ‘FuncType’ with no type [-fpermissive]
     FuncType(FuncDecl f_, std::vector<Expression> args_) 
                                                        ^
../exp_hierarchy/metafunc.hh:29:26: error: invalid declarator before ‘_declarations’
   std::vector<FuncTypes> _declarations;
                          ^
../exp_hierarchy/metafunc.hh:41:52: error: expected ‘(’ before ‘;’ token
   FuncDecl find(std::vector<Expression> args) throw;
                                                    ^
../exp_hierarchy/metafunc.hh:41:52: error: expected type-specifier before ‘;’ token
../exp_hierarchy/metafunc.hh:41:52: error: expected ‘)’ before ‘;’ token
../exp_hierarchy/metafunc.hh: In member function ‘int MetaFunc::FuncTypes::FuncType(FuncDecl, std::vector<ExpressionBase*>)’:
../exp_hierarchy/metafunc.hh:25:9: error: only constructors take member initializers
       : f(f_),args(args_){
         ^
../exp_hierarchy/metafunc.hh:25:9: error: class ‘MetaFunc::FuncTypes’ does not have any field named ‘f’
make: *** wait: No child processes.  Stop.
make: *** Waiting for unfinished jobs....
make: *** wait: No child processes.  Stop.
